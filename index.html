<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Image Merger App - cr.Munchit</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* --- THEME VARIABLES --- */
    :root {
      /* Dark Mode (Default) */
      --primary: #3b82f6;
      --bg-body: #09090b;
      --bg-dots: #27272a;
      --panel-bg: rgba(24, 24, 27, 0.95);
      --border: rgba(255, 255, 255, 0.15);
      --text-main: #e4e4e7;
      --text-muted: #a1a1aa;
      --input-bg: rgba(255, 255, 255, 0.05);
      --toolbar-bg: rgba(30, 30, 35, 0.95);
      --shadow: rgba(0,0,0,0.5);
    }

    /* Light Mode */
    body.light-mode {
      --bg-body: #e8e8e8;
      --bg-dots: #d1d5db;
      --panel-bg: rgba(255, 255, 255, 0.95);
      --border: #d1d5db;
      --text-main: #111827;
      --text-muted: #4b5563;
      --input-bg: #f3f3f3;
      --toolbar-bg: #ffffff;
      --shadow: rgba(0,0,0,0.15);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-body);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: flex;
      transition: background 0.3s, color 0.3s;
      /* Prevent elastic scrolling on Mac/iPad */
      overscroll-behavior: none;
    }

    .app-container {
      display: flex;
      width: 100%;
      height: 100%;
    }

    /* --- SIDEBAR --- */
    .sidebar {
      width: 340px;
      min-width: 300px;
      background: var(--panel-bg);
      border-right: 1px solid var(--border);
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
      z-index: 20; 
      transition: transform 0.3s ease;
    }
    
    .sidebar::-webkit-scrollbar { width: 5px; }
    .sidebar::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
    }

    .logo {
      font-size: 1rem;
      font-weight: 700;
      color: var(--primary);
      line-height: 1.2;
    }

    /* Switch Toggle */
    .switch {
      position: relative;
      display: inline-block;
      width: 48px;
      height: 24px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #3f3f46;
      transition: .4s;
      border-radius: 24px;
      border: 1px solid var(--border);
    }
    .slider:before {
      position: absolute;
      content: "üåô";
      display: flex; align-items: center; justify-content: center;
      font-size: 10px;
      height: 18px; width: 18px;
      left: 3px; bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider { background-color: var(--primary); }
    input:checked + .slider:before {
      transform: translateX(22px);
      content: "‚òÄÔ∏è";
    }

    .mobile-toggle { display: none; background:none; border:none; color:var(--text-main); font-size:1.5rem; }

    /* Controls */
    .control-section {
      background: var(--input-bg);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    
    .control-header {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      margin-bottom: 8px;
      color: var(--text-muted);
      font-weight: 600;
      text-transform: uppercase;
    }
    .control-val { color: var(--primary); font-family: monospace; font-size: 0.9rem; }
    
    input[type="range"] {
      width: 100%;
      height: 20px;
      background: transparent;
      -webkit-appearance: none;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: var(--border);
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      margin-top: -8px;
      width: 20px;
      height: 20px;
      background: var(--primary);
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      border: 2px solid #fff;
    }

    select {
      width: 100%;
      padding: 10px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      border-radius: 8px;
      outline: none;
      font-size: 0.9rem;
      cursor: pointer;
    }
    select option {
      background: var(--bg-body);
      color: var(--text-main);
    }

    .upload-box {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      background: var(--input-bg);
      transition: 0.2s;
      color: var(--text-muted);
    }
    .upload-box:hover { border-color: var(--primary); color: var(--primary); background: rgba(59, 130, 246, 0.05); }

    .img-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .thumb {
      aspect-ratio: 1;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
      background: #000;
      border: 1px solid var(--border);
    }
    .thumb img { width: 100%; height: 100%; object-fit: cover; opacity: 1; transition: 0.2s; }
    .thumb:hover img { opacity: 0.7; }
    .thumb-del {
      position: absolute; inset: 0; 
      background: rgba(220, 38, 38, 0.8); color: #fff;
      display: flex; align-items: center; justify-content: center;
      opacity: 0; transition: 0.2s; font-size: 1.2rem; cursor: pointer;
    }
    .thumb:hover .thumb-del { opacity: 1; }

    /* --- VIEWPORT --- */
    .viewport {
      flex: 1;
      position: relative;
      background-color: var(--bg-body);
      background-image: 
        linear-gradient(var(--bg-dots) 1px, transparent 1px),
        linear-gradient(90deg, var(--bg-dots) 1px, transparent 1px);
      background-size: 40px 40px;
      
      overflow: hidden;
      
      /* iPad/Mobile Touch Fixes */
      touch-action: none; /* Disables browser scrolling/zooming */
      -webkit-user-select: none; /* Prevent text selection */
      user-select: none;
      
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s;
    }
    .viewport:active { cursor: grabbing; }

    .canvas-wrapper {
      transform-origin: center center;
      box-shadow: 0 0 80px var(--shadow);
      /* Improve touch rendering */
      will-change: transform;
    }
    #previewCanvas { display: block; pointer-events: none; }

    /* --- TOOLBAR --- */
    .toolbar {
      position: absolute;
      bottom: 40px; 
      left: 50%;
      transform: translateX(-50%);
      
      background: var(--toolbar-bg);
      backdrop-filter: blur(12px);
      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 10px 40px var(--shadow);
      z-index: 100;
      touch-action: none;
      user-select: none;
      width: auto;
      white-space: nowrap;
      cursor: grab;
    }
    .toolbar:active { cursor: grabbing; }

    .btn {
      background: var(--input-bg);
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 10px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }
    .btn:hover { transform: translateY(-2px); filter: brightness(1.05); }
    .btn-primary { background: var(--primary); border:none; color:white; }
    .btn-danger { color: #ef4444; border-color: rgba(239, 68, 68, 0.3); }
    .btn-danger:hover { background: rgba(239, 68, 68, 0.1); }
    
    .view-info {
        position: absolute; top: 20px; right: 20px;
        background: var(--panel-bg); padding: 6px 14px;
        border-radius: 20px; font-size: 0.75rem; color: var(--text-muted);
        pointer-events: none; border: 1px solid var(--border);
    }

    @media (max-width: 768px) {
      .app-container { flex-direction: column; }
      .sidebar {
        position: fixed; top: 0; left: 0; bottom: 0;
        width: 85%; max-width: 320px;
        transform: translateX(-100%);
        box-shadow: 10px 0 50px rgba(0,0,0,0.5);
      }
      .sidebar.active { transform: translateX(0); }
      
      .mobile-header {
        display: flex; justify-content: space-between; align-items: center;
        padding: 15px; background: var(--bg-body); border-bottom: 1px solid var(--border);
        z-index: 10;
      }
      .mobile-toggle { display: block; }
      
      .toolbar {
        left: 50% !important;
        transform: translateX(-50%) !important;
        bottom: 20px !important;
        top: auto !important;
        cursor: default;
      }
    }
  </style>
</head>
<body>

  <div class="mobile-header" style="display:none;" id="mobileHeader">
    <button class="mobile-toggle" id="menuBtn">‚ò∞</button>
    <span style="font-weight:700; color:var(--primary);">AI Collage</span>
    <div style="width:24px;"></div>
  </div>

  <div class="app-container">
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">image-merger-app<br><span style="font-size:0.8em; opacity:0.6; font-weight:400;">cr.Munchit</span></div>
        <div style="display:flex; align-items:center; gap:15px;">
             <label class="switch" title="Toggle Light/Dark">
               <input type="checkbox" id="themeToggle">
               <span class="slider"></span>
             </label>
             <button class="mobile-toggle" id="closeMenuBtn" style="font-size:1.2rem;">‚úï</button>
        </div>
      </div>
      
      <div class="upload-box" id="dropZone">
        <div style="font-size:2rem; margin-bottom:5px;">üì∑</div>
        <div>Add Images</div>
        <div style="font-size:0.75rem; opacity:0.7;">Click or Drag & Drop / Paste</div>
        <input type="file" id="fileInput" multiple accept="image/*" style="display:none">
      </div>

      <div class="control-section">
        <div class="control-header">Paper Shape</div>
        <select id="aspectRatio">
            <option value="auto">Auto (Infinite Height)</option>
            <option value="1">Square (1:1)</option>
            <option value="0.75">Portrait (3:4)</option>
            <option value="1.333">Landscape (4:3)</option>
            <option value="1.777">Story/Screen (16:9)</option>
        </select>
      </div>

      <div class="control-section">
        <div class="control-header">
          <span>Max Resolution</span>
          <span class="control-val" id="widthVal">AUTO</span>
        </div>
        <input type="range" id="canvasWidth" min="0" max="8000" step="100" value="0">
        <p style="font-size:0.7rem; color:var(--text-muted); margin-top:5px;">0 = Smart Auto-Size</p>
      </div>

      <div class="control-section">
        <div class="control-header">
          <span>Gap / Padding</span>
          <span class="control-val" id="padVal">10px</span>
        </div>
        <input type="range" id="padding" min="0" max="100" value="10">
      </div>

      <div class="control-section">
        <div class="control-header">
          <span>Image Scale</span>
          <span class="control-val" id="scaleVal">AUTO</span>
        </div>
        <input type="range" id="imgScale" min="0" max="150" value="0">
      </div>

      <div class="control-section">
        <div class="control-header">Background</div>
        <div style="display:flex; gap:10px; align-items:center;">
             <input type="color" id="bgColor" value="#ffffff" style="flex:1; height:35px; border:none; border-radius:6px; cursor:pointer;">
             <label style="font-size:0.8rem; display:flex; align-items:center; gap:5px; color:var(--text-main);">
               <input type="checkbox" id="transparentBg"> Transparent
             </label>
        </div>
      </div>

      <div style="font-size:0.75rem; color:var(--text-muted); font-weight:700; margin-top:5px;">
        IMAGES (<span id="imgCount">0</span>)
      </div>
      <div class="img-grid" id="imgList"></div>
    </div>

    <div class="viewport" id="viewport">
      <div class="view-info">2 Fingers to Zoom ‚Ä¢ 1 Finger to Drag</div>
      
      <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="previewCanvas"></canvas>
      </div>
      
      <div class="toolbar" id="toolbar">
        <button class="btn btn-primary" id="downloadPng">üíæ PNG</button>
        <button class="btn" id="downloadPdf">üìÑ PDF</button>
        <button class="btn btn-danger" id="clearBtn" title="Clear All">üóëÔ∏è</button>
      </div>
    </div>
  </div>

  <script>
    // --- 0. THEME SWITCHER ---
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('change', () => {
        if(themeToggle.checked) {
            document.body.classList.add('light-mode');
        } else {
            document.body.classList.remove('light-mode');
        }
    });

    // --- 1. DRAG TOOLBAR ---
    class DraggableToolbar {
        constructor(id) {
            this.el = document.getElementById(id);
            this.isDragging = false;
            this.mouseOffsetX = 0;
            this.mouseOffsetY = 0;

            this.el.addEventListener('mousedown', this.onStart.bind(this));
            window.addEventListener('mousemove', this.onMove.bind(this));
            window.addEventListener('mouseup', this.onEnd.bind(this));
            window.addEventListener('resize', this.clampPosition.bind(this));
            
            // Touch support for Toolbar
            this.el.addEventListener('touchstart', (e) => this.onStart(e), { passive: false });
            window.addEventListener('touchmove', (e) => this.onMove(e), { passive: false });
            window.addEventListener('touchend', (e) => this.onEnd(e));
        }

        onStart(e) {
            if(window.innerWidth <= 768) return; 
            if(e.target.tagName === 'BUTTON' || e.target.closest('button')) return; 
            
            // Support both Mouse and Touch
            const evt = e.type.includes('touch') ? e.touches[0] : e;
            
            if(!e.type.includes('touch')) e.preventDefault(); 

            this.isDragging = true;
            
            const rect = this.el.getBoundingClientRect();
            const parentRect = this.el.offsetParent.getBoundingClientRect();
            
            this.mouseOffsetX = evt.clientX - rect.left;
            this.mouseOffsetY = evt.clientY - rect.top;

            const relLeft = rect.left - parentRect.left;
            const relTop = rect.top - parentRect.top;

            this.el.style.transform = 'none';
            this.el.style.bottom = 'auto';
            this.el.style.right = 'auto';
            this.el.style.left = relLeft + 'px';
            this.el.style.top = relTop + 'px';
            
            this.el.style.cursor = 'grabbing';
        }

        onMove(e) {
            if (!this.isDragging) return;
            e.preventDefault(); // Stop Scroll

            const evt = e.type.includes('touch') ? e.touches[0] : e;
            const parentRect = this.el.offsetParent.getBoundingClientRect();
            
            const screenX = evt.clientX;
            const screenY = evt.clientY;

            const desiredScreenLeft = screenX - this.mouseOffsetX;
            const desiredScreenTop = screenY - this.mouseOffsetY;

            let newLeft = desiredScreenLeft - parentRect.left;
            let newTop = desiredScreenTop - parentRect.top;

            const maxLeft = parentRect.width - this.el.offsetWidth;
            const maxTop = parentRect.height - this.el.offsetHeight;
            const padding = 10;

            if (newLeft < padding) newLeft = padding;
            if (newTop < padding) newTop = padding;
            if (newLeft > maxLeft - padding) newLeft = maxLeft - padding;
            if (newTop > maxTop - padding) newTop = maxTop - padding;

            this.el.style.left = newLeft + 'px';
            this.el.style.top = newTop + 'px';
        }

        onEnd() {
            this.isDragging = false;
            this.el.style.cursor = 'grab';
        }

        clampPosition() {
            if(window.innerWidth <= 768) {
                this.el.style.left = '50%';
                this.el.style.transform = 'translateX(-50%)';
                this.el.style.bottom = '20px';
                this.el.style.top = 'auto';
            }
        }
    }

    // --- 2. VIEWPORT (Enhanced for iPad/Touch) ---
    class ViewportController {
        constructor(viewportId, wrapperId) {
            this.viewport = document.getElementById(viewportId);
            this.wrapper = document.getElementById(wrapperId);
            this.scale = 0.5; 
            this.panX = 0;
            this.panY = 0;
            
            // State
            this.isPanning = false;
            this.lastX = 0;
            this.lastY = 0;
            
            // Pinch State
            this.initialPinchDist = 0;
            this.initialScale = 1;

            this.bindEvents();
        }

        bindEvents() {
            // MOUSE
            this.viewport.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = -e.deltaY;
                const newScale = delta > 0 ? this.scale * 1.1 : this.scale / 1.1;
                this.updateTransform(newScale, this.panX, this.panY);
            }, { passive: false });

            this.viewport.addEventListener('mousedown', (e) => {
                if(e.target.closest('.toolbar')) return;
                this.isPanning = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.viewport.style.cursor = 'grabbing';
            });

            window.addEventListener('mousemove', (e) => {
                if (!this.isPanning) return;
                e.preventDefault();
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                this.panX += dx;
                this.panY += dy;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.checkBounds();
                this.updateTransform(this.scale, this.panX, this.panY);
            });

            window.addEventListener('mouseup', () => {
                this.isPanning = false;
                this.viewport.style.cursor = 'grab';
            });

            // TOUCH (iPad / Mobile)
            this.viewport.addEventListener('touchstart', (e) => {
                if(e.target.closest('.toolbar')) return;
                
                // Prevent default to stop native browser zoom/scroll
                if(e.cancelable) e.preventDefault();

                if (e.touches.length === 1) {
                    // Single Touch = Pan
                    this.isPanning = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    // Two Finger = Pinch
                    this.isPanning = false; // Stop panning
                    this.initialPinchDist = this.getDist(e.touches);
                    this.initialScale = this.scale;
                }
            }, { passive: false });

            this.viewport.addEventListener('touchmove', (e) => {
                if(e.target.closest('.toolbar')) return;
                if(e.cancelable) e.preventDefault();

                if (e.touches.length === 1 && this.isPanning) {
                    // Pan
                    const dx = e.touches[0].clientX - this.lastX;
                    const dy = e.touches[0].clientY - this.lastY;
                    this.panX += dx;
                    this.panY += dy;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.checkBounds();
                    this.updateTransform(this.scale, this.panX, this.panY);
                } else if (e.touches.length === 2) {
                    // Pinch
                    const currentDist = this.getDist(e.touches);
                    if (this.initialPinchDist > 0) {
                        const scaleFactor = currentDist / this.initialPinchDist;
                        const newScale = this.initialScale * scaleFactor;
                        this.updateTransform(newScale, this.panX, this.panY);
                    }
                }
            }, { passive: false });

            this.viewport.addEventListener('touchend', (e) => {
                if(e.touches.length === 0) {
                    this.isPanning = false;
                } else if(e.touches.length === 1) {
                    // Switch back to pan if one finger remains
                    this.isPanning = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                }
            });
        }

        getDist(touches) {
            return Math.hypot(
                touches[0].clientX - touches[1].clientX,
                touches[0].clientY - touches[1].clientY
            );
        }

        checkBounds() {
            const limitX = this.viewport.clientWidth;
            const limitY = this.viewport.clientHeight;
            if (this.panX > limitX) this.panX = limitX;
            if (this.panX < -limitX) this.panX = -limitX;
            if (this.panY > limitY) this.panY = limitY;
            if (this.panY < -limitY) this.panY = -limitY;
        }

        updateTransform(scale, x, y) {
            if (scale < 0.05) scale = 0.05;
            if (scale > 10) scale = 10;
            this.scale = scale;
            this.wrapper.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        }
    }

    // --- 3. BIN PACKING ---
    class MaxRectsPacker {
        constructor(width, height) {
            this.binWidth = width;
            this.binHeight = height;
            this.freeRectangles = [{ x: 0, y: 0, w: width, h: height }];
        }
        insert(width, height, data) {
            let bestNode = { rect: null, score1: Infinity, score2: Infinity };
            for (let i = 0; i < this.freeRectangles.length; i++) {
                const freeRect = this.freeRectangles[i];
                if (freeRect.w >= width && freeRect.h >= height) {
                    const leftoverHoriz = Math.abs(freeRect.w - width);
                    const leftoverVert = Math.abs(freeRect.h - height);
                    const shortSideFit = Math.min(leftoverHoriz, leftoverVert);
                    const longSideFit = Math.max(leftoverHoriz, leftoverVert);
                    if (shortSideFit < bestNode.score1 || (shortSideFit == bestNode.score1 && longSideFit < bestNode.score2)) {
                        bestNode.rect = { x: freeRect.x, y: freeRect.y, w: width, h: height };
                        bestNode.score1 = shortSideFit;
                        bestNode.score2 = longSideFit;
                    }
                }
            }
            if (bestNode.rect) {
                this.placeRect(bestNode.rect);
                return { x: bestNode.rect.x, y: bestNode.rect.y, w: width, h: height, data: data };
            }
            return null;
        }
        placeRect(rect) {
            const numRectsToProcess = this.freeRectangles.length;
            for (let i = 0; i < numRectsToProcess; i++) {
                if (this.splitFreeNode(this.freeRectangles[i], rect)) {
                    this.freeRectangles.splice(i, 1);
                    i--;
                }
            }
            this.pruneFreeList();
        }
        splitFreeNode(freeNode, usedNode) {
            if (usedNode.x >= freeNode.x + freeNode.w || usedNode.x + usedNode.w <= freeNode.x ||
                usedNode.y >= freeNode.y + freeNode.h || usedNode.y + usedNode.h <= freeNode.y) return false;
            if (usedNode.x < freeNode.x + freeNode.w && usedNode.x + usedNode.w > freeNode.x) {
                if (usedNode.y > freeNode.y && usedNode.y < freeNode.y + freeNode.h) {
                    this.freeRectangles.push({ x: freeNode.x, y: freeNode.y, w: freeNode.w, h: usedNode.y - freeNode.y });
                }
                if (usedNode.y + usedNode.h < freeNode.y + freeNode.h) {
                    this.freeRectangles.push({ x: freeNode.x, y: usedNode.y + usedNode.h, w: freeNode.w, h: freeNode.y + freeNode.h - (usedNode.y + usedNode.h) });
                }
            }
            if (usedNode.y < freeNode.y + freeNode.h && usedNode.y + usedNode.h > freeNode.y) {
                if (usedNode.x > freeNode.x && usedNode.x < freeNode.x + freeNode.w) {
                    this.freeRectangles.push({ x: freeNode.x, y: freeNode.y, w: usedNode.x - freeNode.x, h: freeNode.h });
                }
                if (usedNode.x + usedNode.w < freeNode.x + freeNode.w) {
                    this.freeRectangles.push({ x: usedNode.x + usedNode.w, y: freeNode.y, w: freeNode.x + freeNode.w - (usedNode.x + usedNode.w), h: freeNode.h });
                }
            }
            return true;
        }
        pruneFreeList() {
            for (let i = 0; i < this.freeRectangles.length; i++) {
                for (let j = i + 1; j < this.freeRectangles.length; j++) {
                    if (this.isContainedIn(this.freeRectangles[i], this.freeRectangles[j])) {
                        this.freeRectangles.splice(i, 1);
                        i--;
                        break;
                    }
                    if (this.isContainedIn(this.freeRectangles[j], this.freeRectangles[i])) {
                        this.freeRectangles.splice(j, 1);
                        j--;
                    }
                }
            }
        }
        isContainedIn(a, b) {
            return a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h;
        }
    }

    // --- 4. APP LOGIC ---
    class App {
        constructor() {
            this.images = []; 
            this.layoutResult = []; 
            this.canvas = document.getElementById('previewCanvas');
            this.ctx = this.canvas.getContext('2d');
            
            this.ui = {
                fileInput: document.getElementById('fileInput'),
                dropZone: document.getElementById('dropZone'),
                canvasWidth: document.getElementById('canvasWidth'),
                widthVal: document.getElementById('widthVal'),
                aspectRatio: document.getElementById('aspectRatio'),
                padding: document.getElementById('padding'),
                padVal: document.getElementById('padVal'),
                imgScale: document.getElementById('imgScale'),
                scaleVal: document.getElementById('scaleVal'),
                downloadPng: document.getElementById('downloadPng'),
                downloadPdf: document.getElementById('downloadPdf'),
                clearBtn: document.getElementById('clearBtn'),
                imgList: document.getElementById('imgList'),
                imgCount: document.getElementById('imgCount'),
                bgColor: document.getElementById('bgColor'),
                transparentBg: document.getElementById('transparentBg'),
            };

            this.toolbarControl = new DraggableToolbar('toolbar'); 
            this.viewControl = new ViewportController('viewport', 'canvasWrapper');

            const sidebar = document.getElementById('sidebar');
            const mobileHeader = document.getElementById('mobileHeader');
            if(window.innerWidth <= 768) mobileHeader.style.display = 'flex';
            window.addEventListener('resize', () => mobileHeader.style.display = window.innerWidth <= 768 ? 'flex' : 'none');
            document.getElementById('menuBtn').addEventListener('click', () => sidebar.classList.add('active'));
            document.getElementById('closeMenuBtn').addEventListener('click', () => sidebar.classList.remove('active'));

            this.bindEvents();
        }

        bindEvents() {
            this.ui.dropZone.addEventListener('click', () => this.ui.fileInput.click());
            this.ui.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

            // --- ADDED: Drag & Drop Support ---
            let dragCounter = 0;
            this.ui.dropZone.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                this.ui.dropZone.style.borderColor = 'var(--primary)';
                this.ui.dropZone.style.background = 'rgba(59, 130, 246, 0.05)';
            });
            this.ui.dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if(dragCounter === 0) {
                    this.ui.dropZone.style.borderColor = '';
                    this.ui.dropZone.style.background = '';
                }
            });
            this.ui.dropZone.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow drop
            });
            this.ui.dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dragCounter = 0;
                this.ui.dropZone.style.borderColor = '';
                this.ui.dropZone.style.background = '';
                
                if(e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    this.handleFiles(e.dataTransfer.files);
                }
            });

            // --- ADDED: Paste Support (Ctrl+V) ---
            window.addEventListener('paste', (e) => {
                if(e.clipboardData && e.clipboardData.items) {
                    const files = [];
                    for(let item of e.clipboardData.items) {
                        if(item.type.startsWith('image/')) {
                            files.push(item.getAsFile());
                        }
                    }
                    if(files.length > 0) {
                        e.preventDefault();
                        this.handleFiles(files);
                    }
                }
            });

            this.ui.canvasWidth.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                this.ui.widthVal.textContent = val === 0 ? 'AUTO' : val + 'px';
                this.schedulePack();
            });
            this.ui.aspectRatio.addEventListener('change', () => this.schedulePack());
            this.ui.padding.addEventListener('input', (e) => {
                this.ui.padVal.textContent = e.target.value + 'px';
                this.schedulePack();
            });
            this.ui.imgScale.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                this.ui.scaleVal.textContent = val === 0 ? 'AUTO' : val + '%';
                this.schedulePack();
            });
            this.ui.bgColor.addEventListener('input', () => this.render());
            this.ui.transparentBg.addEventListener('change', () => this.render());

            this.ui.clearBtn.addEventListener('click', () => this.clearAll());
            this.ui.downloadPng.addEventListener('click', () => this.download('png'));
            this.ui.downloadPdf.addEventListener('click', () => this.download('pdf'));
        }

        async handleFiles(files) {
            const newImages = [];
            for(let file of files) {
                if(!file.type.startsWith('image/')) continue;
                try {
                    const img = await this.loadImage(file);
                    newImages.push({ id: Date.now() + Math.random(), img, w: img.width, h: img.height });
                } catch(e) { console.error(e); }
            }
            this.images = [...this.images, ...newImages];
            this.updateSidebarList();
            this.packImages(true); 
        }

        loadImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        updateSidebarList() {
            this.ui.imgList.innerHTML = '';
            this.ui.imgCount.textContent = this.images.length;
            this.images.forEach(data => {
                const div = document.createElement('div');
                div.className = 'thumb';
                div.innerHTML = `<img src="${data.img.src}"><div class="thumb-del">√ó</div>`;
                div.querySelector('.thumb-del').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeImage(data.id);
                });
                this.ui.imgList.appendChild(div);
            });
        }

        removeImage(id) {
            this.images = this.images.filter(img => img.id !== id);
            this.updateSidebarList();
            this.packImages();
        }

        clearAll() {
            if(!confirm('Delete all?')) return;
            this.images = [];
            this.layoutResult = [];
            this.updateSidebarList();
            this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
        }

        debounceTimer = null;
        schedulePack() {
            clearTimeout(this.debounceTimer);
            this.debounceTimer = setTimeout(() => this.packImages(), 250);
        }

        packImages(fitScreen = false) {
            if(this.images.length === 0) return;

            let targetW = parseInt(this.ui.canvasWidth.value);
            const padding = parseInt(this.ui.padding.value);
            const ratioSetting = this.ui.aspectRatio.value;
            const userScale = parseInt(this.ui.imgScale.value);

            let targetH = 99999; 
            let fixedRatio = false;
            let ratioVal = 1;

            if(ratioSetting !== 'auto') {
                fixedRatio = true;
                ratioVal = parseFloat(ratioSetting);
            }

            let sorted = [...this.images].sort((a,b) => (b.w * b.h) - (a.w * a.h));
            let globalScale = 1;

            // --- AUTO RESOLUTION LOGIC ---
            if (targetW === 0) {
                const totalArea = sorted.reduce((sum, img) => sum + (img.w * img.h), 0);
                if (fixedRatio) {
                    targetW = Math.ceil(Math.sqrt(totalArea * ratioVal * 1.1));
                } else {
                    const maxImgW = Math.max(...sorted.map(i => i.w));
                    const idealSquareW = Math.ceil(Math.sqrt(totalArea));
                    targetW = Math.max(maxImgW + padding*2, idealSquareW);
                }
                if(targetW < 1000) targetW = 1000;
                if(targetW > 8000) targetW = 8000;
            }

            if(fixedRatio) {
                targetH = targetW / ratioVal;
            }

            if (userScale > 0) {
                globalScale = userScale / 100;
            } else {
                const totalImgArea = sorted.reduce((sum, img) => sum + (img.w * img.h), 0);
                if (fixedRatio) {
                    const targetArea = (targetW * targetH) * 0.9; 
                    globalScale = Math.sqrt(targetArea / totalImgArea);
                    if(globalScale > 1.2) globalScale = 1.2;
                } else {
                    const maxImgW = Math.max(...sorted.map(i => i.w));
                    if(maxImgW > targetW) globalScale = (targetW - padding*2) / maxImgW;
                }
            }

            let success = false;
            let attempts = 0;
            const maxAttempts = fixedRatio ? 15 : 1; 
            let bestResult = null;
            let bestMaxY = 0;

            while(!success && attempts < maxAttempts) {
                const layoutItems = sorted.map(img => {
                    let finalW = Math.floor(img.w * globalScale);
                    let finalH = Math.floor(img.h * globalScale);
                    if(finalW > targetW - padding) {
                        const shrink = (targetW - padding) / finalW;
                        finalW *= shrink;
                        finalH *= shrink;
                    }
                    return { w: finalW + padding, h: finalH + padding, drawW: finalW, drawH: finalH, original: img };
                });

                const packer = new MaxRectsPacker(targetW, fixedRatio ? targetH : 999999);
                let currentResult = [];
                let currentMaxY = 0;
                let allFit = true;

                for(let item of layoutItems) {
                    const node = packer.insert(item.w, item.h, item);
                    if(node) {
                        currentResult.push(node);
                        if(node.y + node.h > currentMaxY) currentMaxY = node.y + node.h;
                    } else {
                        allFit = false; break;
                    }
                }

                if(allFit) {
                    success = true; bestResult = currentResult; bestMaxY = currentMaxY;
                } else {
                    globalScale *= 0.90; attempts++;
                }
            }
            
            this.layoutResult = bestResult || [];
            this.canvas.width = targetW;
            this.canvas.height = fixedRatio ? targetH : bestMaxY;
            
            this.render();
        }

        render() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if(!this.ui.transparentBg.checked) {
                this.ctx.fillStyle = this.ui.bgColor.value;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            const padding = parseInt(this.ui.padding.value);
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';

            this.layoutResult.forEach(node => {
                const img = node.data.original.img;
                const x = node.x + padding/2;
                const y = node.y + padding/2;
                this.ctx.drawImage(img, x, y, node.data.drawW, node.data.drawH);
            });
        }

        download(type) {
            if(this.layoutResult.length === 0) return alert('No images!');
            if(type === 'png') {
                const link = document.createElement('a');
                link.download = `collage-${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            } else if(type === 'pdf') {
                const { jsPDF } = window.jspdf;
                const orientation = this.canvas.width > this.canvas.height ? 'l' : 'p';
                const pdf = new jsPDF({ orientation, unit: 'px', format: [this.canvas.width, this.canvas.height] });
                pdf.addImage(this.canvas.toDataURL('image/jpeg', 0.95), 'JPEG', 0, 0, this.canvas.width, this.canvas.height);
                pdf.save(`collage-${Date.now()}.pdf`);
            }
        }
    }

    window.onload = () => new App();
  </script>
</body>
</html>
